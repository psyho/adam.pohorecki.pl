<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Adam Pohorecki]]></title>
  <link href="http://adam.pohorecki.pl/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://adam.pohorecki.pl/"/>
  <updated>2013-11-06T10:04:43+01:00</updated>
  <id>http://adam.pohorecki.pl/</id>
  <author>
    <name><![CDATA[Adam Pohorecki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More Ruby than Ruby talk at KRUG]]></title>
    <link href="http://adam.pohorecki.pl/blog/2013/10/18/more-ruby-than-ruby-talk-at-krug/"/>
    <updated>2013-10-18T00:02:00+02:00</updated>
    <id>http://adam.pohorecki.pl/blog/2013/10/18/more-ruby-than-ruby-talk-at-krug</id>
    <content type="html"><![CDATA[<p>A few days ago a tweet reminded me about a talk I gave on the 6th of August on <a href="http://www.meetup.com/Krakow-Ruby-Users-Group/">KRUG</a>:</p>

<blockquote><p>One trend I&#39;m observing is a lot of rubyists being fed up with messy ruby ecosystem are getting excited or even switch to clojure.</p>&mdash; Piotr Solnica (@_solnic_) <a href="https://twitter.com/_solnic_/statuses/390163528138899456">October 15, 2013</a></blockquote>


<h2>I &#10084; Ruby</h2>

<p>I have been programming in Ruby professionally for over four years now. When I was starting out, there were probably mere dozens of Ruby programmers in Kraków. Compared being one of the thousands of Java developers, programming Ruby felt almost exotic.</p>

<p>Not that long ago, being a Ruby programmer meant being on the bleeding edge of web development. You had to deal with immature and unstable libraries, crappy deployment options and IDEs that didn't offer much more than syntax highlighting. On the other hand, it also meant working with smarter than average people, who were drawn to this technology not just because it was new, but also because it was in many ways superior to the other options out there. I loved it.</p>

<p>A couple of years have passed and I still love Ruby. I actually love it so much, that I called my dog Ruby. However, the times have changed. Rubyland is no longer the domain of adventurous and industrious early adopters. Ruby is now mature, stable and "enterprise-ready". Somewhere along the way Ruby has become the responsible choice of a language for building web apps.</p>

<p>Let's face it: Ruby is a good language to know right now. The jobs are plentiful and well-payed, and the technology is still relatively modern, but progressively more safe and boring. The days of exciting and unpredictable Ruby are almost over, and soon I'll only be able to like it as a friend.</p>

<h2>I &#10084; Clojure</h2>

<p>I have come across this LISP on the JVM quite a while ago, but having had pretty bad experiences with Common LISP at my university, I never had much interest in it until in May of 2012 I came across a <a href="http://www.youtube.com/watch?v=rI8tNMsozo0">presentation given at RailsConf</a> by Clojure's creator, Rich Hickey.</p>

<p>I am a huge believer in Single Responsibility Principle. Most of my classes have one public method. I tend to avoid inheritance and heavily favor composition and delegation. Unfortunately, a language like Ruby punishes you for coding in this style - your small classes end up being split amongst hundreds of files and often wrapping a function in a class seems like an overhead.</p>

<p>Watching that video made me realize that maybe I should look into functional programming languages. After all, functions are smaller units of composition, and they are easier to combine. I watched a bunch of other Hickey's presentations and I got hooked on Clojure.</p>

<p>Compared to other functional languages like Scala or Haskell, Clojure, as a dynamically typed language, was much more up my alley (in the dispute between static typing vs TDD, I stand strongly behind TDD). It also appealed to me more than Erlang, since I mostly work on web apps, and Clojure seems to do better with those.</p>

<h2>Clojure > Ruby</h2>

<p>I read a couple of books about Clojure, started playing with the language and I fell in love with it.</p>

<p>Let's start with the fact, that Clojure is perfectly capable of expressing pretty much everything that Ruby can, most of the time just as concisely. This in itself is not much of an achievement, but factor into that the syntax of both languages. Even I could write a parser for Clojure. Do you know anyone who could write a parser for Ruby? Clojure's syntax is the perfect marriage of power and simplicity.</p>

<p>Clojure has real namespaces, where Ruby only has modules. Clojure's keywords can be namespaced as well. It avoids Ruby's method naming problems (like when two libraries adding a method with the same name to a class like String of Array). Clojure has ClojureScript. Clojure is well suited for multithreaded programming. Clojure has macros. Clojure is faster...</p>

<p>I believe that this is a great time to get into Clojure programming. The ecosystem is mature enough that you can find libraries to do pretty much everything you need (even if they are not overly polished). The people in the community are above the average, because they have learned Clojure, not because Clojure programmers are in demand, but because they wanted to. There are also plenty of books, screencasts and other resources to learn Clojure from.</p>

<p>Uncle Bob called Clojure "The Last Programming Language". I would settle for "The Next Big Thing". Dig in while it's hot:)</p>

<h2>Slides</h2>

<p>Unfortunately the presentation was not recorded, so all I have are these slides:</p>

<iframe class="slides" src="http://adam.pohorecki.pl/slides/embedder.html#/slides/clojure-krug/" frameborder="0"></iframe>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure talk at Lambda Lounge]]></title>
    <link href="http://adam.pohorecki.pl/blog/2013/06/27/clojure-talk-at-lambda-lounge/"/>
    <updated>2013-06-27T17:17:00+02:00</updated>
    <id>http://adam.pohorecki.pl/blog/2013/06/27/clojure-talk-at-lambda-lounge</id>
    <content type="html"><![CDATA[<p>On the 28th of March this year I gave a talk about <a href="http://clojure.org/">Clojure</a> on the inaugural meeting of <a href="http://www.meetup.com/Lambda-Lounge-Krakow/">Kraków's Lambda Lounge</a>.</p>

<p>With the questions from the audience this talk run way too long - over an hour and a half. I definitely tried to cram too much content into the presentation - from protocols and multimethods, through macros, first-order functions, immutability to concurrency constructs. Most of those things really deserve a presentation of their own.</p>

<h2>Protocols and Multimethods</h2>

<p>If you ever used an Object-Oriented language like Ruby, you are probably familiar with the concept of polymorphism. Since Clojure is a functional language and it's primary unit of composition is a function, you'd think that by using it you have to sacrifice polymorphic dispatch, but you don't.</p>

<p>Even better, Clojure's polymorphism is much more advanced than that of Ruby, and allows you to dispatch on arbitrary properties of any number of function arguments. Defining type relationships is also more powerful, since they can be defined on a per-function basis (if needed of course). Function-first approach also saves us the headaches of naming conflicts that could happen when including multiple modules into a class in Ruby.</p>

<h2>Functional Programming</h2>

<p>Functional programming is all the rage right now, but many people seem to think that it's all about using first order functions. Once you get to use it however, you suddenly realize that the thing that makes the biggest difference is state management and immutability.</p>

<p>Immutability not only helps in multithreaded environments, but it also makes reasoning about code much easier, because any state change made very explicit by forcing functions to return updated data. This approach to handling state also helps testability by separating your code into the functional core (super easy to test), which you can unit test to your heart's content and imperative shell (interaction with the external world, state management), which you can easily integration test, because there are only a couple of paths possible through it.</p>

<h2>Concurrency Constructs</h2>

<p>I spent a good deal of time in my presentation showing a laundry list of Clojure's concurrency constructs, which certainly are plentiful and seem like a very nice addition to java.util.concurrent. So far I only used atoms, but I don't really deal with multithreaded apps much, hopefully one day that will change:)</p>

<h2>Slides</h2>

<iframe class="slides" src="http://adam.pohorecki.pl/slides/embedder.html#/slides/clojure-lambda/" frameborder="0">
</iframe>


<p>The presentation unfortunately wasn't recorded on video.</p>
]]></content>
  </entry>
  
</feed>
